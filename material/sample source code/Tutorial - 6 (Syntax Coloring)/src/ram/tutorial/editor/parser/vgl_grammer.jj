/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. vgl_grammer.jj */
/*@egen*/ /**
 * JJTree template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{                 STATIC = false;  IGNORE_CASE = true;  COMMON_TOKEN_ACTION = true; //calls commonTokenAction after creating token
  TOKEN_MANAGER_USES_PARSER = true;  USER_TOKEN_MANAGER = false;  USER_CHAR_STREAM = false;  BUILD_PARSER = true;  BUILD_TOKEN_MANAGER = true;                                                              
                                                                             }PARSER_BEGIN(VGLParser)package ram.tutorial.editor.parser;public class VGLParser extends VGLParserBase/*@bgen(jjtree)*/implements VGLParserTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected JJTVGLParserState jjtree = new JJTVGLParserState();

/*@egen*/}PARSER_END(VGLParser)//  =================================================================
//  Define the token manager.
//  =================================================================
TOKEN_MGR_DECLS :{  void CommonTokenAction(Token t)  {}}SKIP :{  " "| "\t"  //| "\n"  //| "\r"| < "//" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) >| < "/*" (~[ "*" ])* "*"    (      ~[ "/" ] (~[ "*" ])* "*"    )*    "/" >}TOKEN : /* LITERALS */{  < INTEGER_LITERAL : < DECIMAL_LITERAL > >| < #DECIMAL_LITERAL : [ "1"-"9" ] ([ "0"-"9" ])* >| < #HEX_LITERAL : "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ >| < #OCTAL_LITERAL : "0" ([ "0"-"7" ])* >}TOKEN : /* Commands *///This declaration must be before identifier, else thse tokens will
//be recognized as identifiers
{  < CANVAS : "CANVAS" >| < POINT : "POINT" >| < LINE : "LINE" >| < CIRCLE : "CIRCLE" >| < BUTTON : "BUTTON" >| < ROTATE : "ROTATE" >| < MESSAGE : "MESSAGE" >| < FUNCTION : "FUNCTION" >}TOKEN : /* IDENTIFIERS */{  < IDENTIFIER :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >| < STR_LITERAL : "\"" ~[ "\n", "\r" ] "\"" >| < #LETTER : [ "_", "a"-"z", "A"-"Z" ] >| < #DIGIT : [ "0"-"9" ] >}TOKEN :{  < EOL :    "\r\n"  | "\r"  | "\n" >}SimpleNode Start() :{/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(this, JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) Start */
  try {
/*@egen*/  (    CommandStatement()  | FunctionDef()  )*  < EOF >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/}void CommandStatement()       :{}{    try    {        Command() ((< EOL >) +    |   < EOF >)    }    catch (ParseException pe)    {        skipToLineEnd(pe);    }}void Command()       :{}{  Canvas()| Point()| Line()| Circle()| FunctionCall()}void Point() :{/*@bgen(jjtree) Point */
    ASTPoint jjtn000 = new ASTPoint(this, JJTPOINT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
    Token tk = null;
}{/*@bgen(jjtree) Point */
  try {
/*@egen*/  try  {    < POINT > < INTEGER_LITERAL > < INTEGER_LITERAL >

    tk = < IDENTIFIER >
    {        jjtn000.setPointName(tk.image);
    }  }  catch (ParseException pe)  {    skipToLineEnd(pe);  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/}void Canvas() :{/*@bgen(jjtree) Canvas */
  ASTCanvas jjtn000 = new ASTCanvas(this, JJTCANVAS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) Canvas */
  try {
/*@egen*/  try  {    < CANVAS > < INTEGER_LITERAL > < INTEGER_LITERAL >  }  catch (ParseException pe)  {    skipToLineEnd(pe);  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/}void Circle() :{/*@bgen(jjtree) Circle */
  ASTCircle jjtn000 = new ASTCircle(this, JJTCIRCLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) Circle */
  try {
/*@egen*/  try  {    < CIRCLE > Numeric()  < IDENTIFIER >  }  catch (ParseException pe)  {    skipToLineEnd(pe);  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/}void Line() :{/*@bgen(jjtree) Line */
  ASTLine jjtn000 = new ASTLine(this, JJTLINE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) Line */
  try {
/*@egen*/  try  {    < LINE > (LOOKAHEAD(3)     < IDENTIFIER >  < IDENTIFIER >  < IDENTIFIER >  | ( < IDENTIFIER >  < IDENTIFIER >))  }  catch (ParseException pe)  {    skipToLineEnd(pe);  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/}void Button() :{/*@bgen(jjtree) Button */
  ASTButton jjtn000 = new ASTButton(this, JJTBUTTON);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) Button */
  try {
/*@egen*/  try  {    < BUTTON > < INTEGER_LITERAL > < INTEGER_LITERAL > < STR_LITERAL >
     < IDENTIFIER >  }  catch (ParseException pe)  {    skipToLineEnd(pe);  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/}void FunctionCall() :{/*@bgen(jjtree) FunctionCall */
  ASTFunctionCall jjtn000 = new ASTFunctionCall(this, JJTFUNCTIONCALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) FunctionCall */
  try {
/*@egen*/  try  {     < IDENTIFIER > "()"  }  catch (ParseException pe)  {    skipToLineEnd(pe);  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/}void FunctionDef() :{/*@bgen(jjtree) FunctionDef */
    ASTFunctionDef jjtn000 = new ASTFunctionDef(this, JJTFUNCTIONDEF);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
    jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
    Token tk = null;
}{/*@bgen(jjtree) FunctionDef */
  try {
/*@egen*/  try  {    < FUNCTION >
    tk =  < IDENTIFIER >
    {	       jjtn000.setFunctionName(tk.image);
    }
    (< EOL >) + "{" (< EOL >) + (Command() (< EOL >) +) * "}" (< EOL >) *  }  catch (ParseException pe)  {    skipToLineEnd(pe);  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/}ASTIdentifier Identifier() :{/*@bgen(jjtree) Identifier */
  ASTIdentifier jjtn000 = new ASTIdentifier(this, JJTIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) Identifier */
    try {
/*@egen*/    try    {        < IDENTIFIER >    }    catch (ParseException pe)    {        jjtn000.setException(pe);
        throw pe;    }/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
              jjtreeCloseNodeScope(jjtn000);
              jjtn000.jjtSetLastToken(getToken(0));
            }
/*@egen*/

	    {        return jjtn000;
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/}void FloatNumeric()       :{}{  [ < INTEGER_LITERAL > ] "." < INTEGER_LITERAL >}void Numeric()       :{}{  LOOKAHEAD(2)  < INTEGER_LITERAL >| FloatNumeric()}JAVACODE void skipToLineEnd(Exception e)      {  SimpleNode currNode = getCurrentNode();
  if (currNode != null)     currNode.setException(e);			  Token t = null;										  	do  {      t = getToken(1);      if (t != null && (t.kind == EOL || t.kind == EOF)) break;      t = getNextToken();      if (currNode != null)          currNode.addSkippedToken(t);  }while (t != null);}